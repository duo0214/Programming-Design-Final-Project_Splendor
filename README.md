# Programming-Design-Final-Project_Splendor
---
## 1 璀璨寶石簡介 
1. 遊戲概要：璀璨寶石（Splendor）是一款 2~4 人的桌遊，規則簡單容易上手，卻也能透過策略運用玩得相當有深度。遊戲設定在文藝復興時期，玩家扮演寶石商人，目標是收集和交易寶石以贏得聲望點數。
2. 遊戲目標與勝利條件：玩家需要通過購買卡牌以及解鎖貴族成就的方式來贏得遊戲。每張卡牌都有特定的寶 石成本及聲望點數，貴族卡則需要擁有一定數量的特定卡牌，方能獲得額外聲望值。玩 家每回合輪流進行，最先獲得 15 點聲望值的玩家（且該回合沒有人能超過其分數）獲勝。
3. 遊戲配置
* 寶石：有白、黑、紅、藍、綠、黃金六種寶石顏色，用於購買寶石卡片。在消費時，黃金得代替任何一種顏色的寶石。
* 卡牌：每張卡牌包含聲望點數、顏色折扣及所需花費寶石。卡牌分為三種等級，由高至低分別有 20 張、30 張、40 張卡牌。卡牌等級愈高，所需花費寶石及聲望點數愈高。
* 貴族卡：包含特定的卡牌數量條件，解鎖能獲得額外聲望點數。
4. 遊戲規則
* 4種操作
  * 拿取 3 個不同顏色的寶石
  * 拿取 2 個不同顏色的寶石
  * 保留場上 1 張牌並獲得 1 個黃金
  * 購買場上 1 張牌或保留牌
* 玩家在回合結束時不能擁有超過 10 個寶石
* 一位玩家所持有的保留牌不得超過 3 張
* 持有的卡牌紅利在後續購買時能折抵所需花費寶石
* 因應專案的調整為了讓遊戲能夠進行較快速以及方便開發，我們將遊戲人數限制在 2 人，將貴族相關的規則拿掉，並把勝利條件改為只需獲得 5 點聲望值即獲勝。

## 2 系統設計
### 後端
1. 類別「Diamond」：「Diamond」是這個遊戲用以購買卡牌的貨幣，場面上有一組供玩家拿取的寶石，每位玩家自己會有一組、以及每張卡牌有一組所需花寶石。以下是「Diamond」的實作方式：
* 變數定義：類別中定義了一個長度為 6（寶石種類數）的陣列diamonds，每一個 index 分別儲存了每一種顏色的寶石，並透過 enum 所定義的常數 WHITE、 BLACK、RED、GREEN、BLUE、GOLD 共 6 個常數(分別對應整數 0~6)，來增加讀取、修改diamonds的可讀性。舉例來說，當diamonds[WHITE] == 5，則代表該組寶石中白寶石有5顆。
* Operator Overloading：此類別定義了「!=」、「-=」、「[]」三種 operator overloading
  * !=：用以比較卡牌物件與傳入參數是否相同的指標之一，若兩張牌的 spendDimd 變數不相等，則確定兩者並非同一張牌。
  * -=：玩家在操作買牌行為時，會從自己的 myDiamonds 中扣除相對應的 spendDimd。
  * []：能直接讀取寶石物件中的 diamonds 陣列，增加可讀性，並分為 const 版本（只能讀取）與非 const 版本（能當左值）。

2. 類別「Card」：「Card」為遊戲中獲得聲望點數的工具，以下是「Card」的組成及功能：
* 變數定義：類別中定義了卡牌的等級 level、買進牌後所獲得的折扣顏色 color、聲望點數 score 以及購買牌所需花費的寶石數量 spendDimd。
* Operator Overloading：此類別定義了「==」的 operator overloading。當一位玩家要購買手中的保留牌時，此功能確認卡牌物件是否與傳入參數相等。
* 其他功能：一些「Player」存取卡牌資訊時所會用到的getter，包含 getScore、getColor、getDiamond。

3. 類別「Player」：「Player」用來記錄每個玩家的資訊以及可行的動作，用來在主遊戲進行時，依據當前玩家回合進行動作。以下是「Player」類別的主要組成及其功能：
* 變數定義：類別中定義了玩家目前的分數 point、買下的牌 myCards、預約下的牌 myReservedCards 及現在有多少紅利discount[]。
* 玩家行動：這些成員函數包括玩家所有在一個回合內可選擇的行為，包買牌buyCard（若此購買需要用到金幣，則呼叫）、預約牌 reserveCard 、買下預約的牌 buyReserveCard、拿取寶石 takeDiamond（依照要拿同色還是三色的寶石多載此函數）。
* 錯誤檢查：若玩家手上超過了 10 個寶石，歸還寶石的函數 returnDiamond 會被呼叫，同樣依照需要歸還的數量多載此函數。而在上述行動函數中，若玩家選擇了不可行的動作，函數會回傳一個作物並印出錯誤訊息。可能的錯誤包含：場上的寶石不夠拿、玩家本人及使用了金幣和紅利仍買不起他點選的卡片、預約牌以經三張卻仍點了預約。

4. 類別「Game」：「Game」類別是本遊戲的核心部分，主要負責遊戲的進程控制和規則實施。這個類別與其他幾個類別（如「Cards」、「Players」和「Diamonds」）相互作用，共同構成遊戲的完整架構。以下是「Game」類別的主要組成及其功能：
* 變數定義：類別中定義了多個靜態常量和成員變數，用於表示遊戲中的基本參數，如卡牌行列數 Card_ROWS、Card_COLS、寶石類型數 DIAMONDS 和玩家數量 Players_CNT。
* 卡牌和玩家管理：透過向量存儲不同等級的卡牌（如 mines、transport、vendors），並使用指標陣列 players 來管理玩家。這種方式方便了卡牌和玩家資源的動態分配和釋放。
* 遊戲流程控制：類別中包含了許多控制遊戲流程的函數，如 playGame、 setboard 和 update_board 等。這些函數負責遊戲的開始、遊戲檯面卡牌的設置和更新檯面卡牌等關鍵環節。
* 玩家互動處理：get_command 函數用於處理玩家的行動指令，根據前端發送的指令執行相應的遊戲邏輯。
* 記憶體管理：類別的構造函數和析構函數 Game、~Game 和 clear_memory 確保了動態分配的記憶體的正確初始化和釋放，避免了內存洩漏的問題。

### 前端 SFML

「SFML」這個套件協助將遊戲後端設定的內容，包括卡牌、寶石、寶石折扣、分數等進行視覺化的呈現、以及動態的資訊更新。以下為 SFML 的主要組成以及功能：
1. 變數設定：此套件透過許多位置向量的設定，及圖片的讀取，將各種資訊分別呈現於不同的位置，並在必要時進行移動及更新，包含視窗的建立、背景的設定、牌桌上卡牌、寶石的位置、及玩家的分數、寶石折扣的更新。
2. 玩家互動處理：透過滑鼠點擊視窗中的不同位置，執行相應的遊戲操作，包括卡牌的購買及預定、寶石的拿取、螢幕視窗的關閉。

## 3 演算法
1. 類別「Game」的重要演算邏輯：在 Game 類別中實現的演算法主要集中於遊戲邏輯的處理，以下是其關鍵的演算法。
* play_game：在類別「Game」的構造函數被呼叫，進行遊戲的主循環，主邏輯是一個無窮迴圈，透過分配 playerNum 的值為 1 或 2 控制目前操作的是玩家 1 還是玩家 2。兩者輪流呼叫 get_command 函數來執行該局操作，執行完該局操作會呼叫函數 diamonds_cnt_over_10 來檢查手上的寶石數量是否超過 10 顆。該無窮迴圈的終止條件是當 Player_Wins 函數回傳一個非零整數時，並在跳出迴圈前呼叫 clear_memory 釋放記憶體空間。上面提及的函數將再下方分別介紹。
* createCardDeck：進行卡牌生成與分配，該函數從檔案中讀取所有的卡牌資訊，並根據卡牌的屬性創建相應的 「Card」類別的物件，再將這些物件存在相對應等級的向量中。
* get_command：根據玩家在前端下的指令，執行購買卡牌、保留卡牌、拿取寶石等行動，若玩家該輪選擇購買或保留卡牌，由於此舉會導致檯面上的牌減少，因此必須呼叫 update_board 更新新的牌於檯面。
* diamonds_cnt_over_10：檢查玩家手上的寶石數量是否大於 10 顆，若大於 10 顆則透過類別「Player」中的 returnDiamond 函數將寶石歸還寶石庫。
* Player_Wins：該函數用來判斷勝利條件，透過檢查兩位玩家的聲望值 point 是否達到 15 點，若有玩家獲勝則回傳非零整數， 1 表示玩家 1 獲勝，2 表示玩家 2 獲勝，若同時達到 15 點即為平手，回傳 3。沒有玩家獲勝則回傳 0，表示遊戲繼續進行。
2. 「SFML」的重要演算邏輯：SFML將後端的各項資訊進行視覺化處理，呈現於玩家的螢幕上，以下為其重要的演算邏輯：
* 遊戲畫面設定：主要透過形狀、背景、位置三個部分進行遊戲中元素的設定及更新，以下為設定的過程：
  * 形狀設定：透過函式如 sf::RectangleShape、sf::CircleShape，初始化各種元素的形狀。
  * 背景設定：利用函式 sf::Texture，將 background 、deckVendor、deckTransport、deckMine 等元素，載入其相應的圖片。
  * 位置設定：利用向量 sf::Vector2f(xPos, yPos)儲存各元素的位置，如玩家手上的卡片（handCards1、handCards2）和預定牌（reservedCards1、 reservedCards2）的位置。
* 事件處理：在程式碼中使用 sf::Event 進行事件處理，主要是針對遊戲窗口的不同事件進行檢測和相應的操作。使用 window.pollEvent(evnt) 進行事件的輪詢，檢查是否有事件發生。事件的主要類型包括：
  * 窗口關閉事件（sf::Event::Closed）：當玩家點擊視窗關閉按鈕時，程式 使用 window.close() 關閉遊戲視窗。
  * 滑鼠按鈕點擊事件（sf::Event::MouseButtonPressed）：透過 evnt.mouseButton.button 判斷是左鍵還是右鍵點擊。根據滑鼠點擊的位置執行相應的遊戲操作，如購買卡片、預定卡片和收集寶石。
* 遊戲循環：程式碼進入一個無窮迴圈，該迴圈不斷運行，確保遊戲一直處於運行狀態。在每一次迴圈中，遊戲進行以下主要操作：
  * 遊戲狀態的更新：調用相應的遊戲控制函數，如 playGame、setboard 和 update_board。確保遊戲檯面上的卡片和寶石處於最新狀態。
  * 玩家互動的處理：根據前端發送的滑鼠點擊事件和指令，透過函數 get_command 進行玩家的互動處理。
  * 視窗的更新：使用 window.clear() 清空畫面，然後繪製更新後的所有遊戲元素。使用 window.display() 顯示更新後的畫面。

## 4 分工方式
**陳研希**：類別 Player 和 Game 等後端程式撰寫。

**張弘蒲**：類別 Player 和 Game 等後端程式撰寫。

**莫仲軒**：前端 SFML 的撰寫。

**羅佳璿**：類別 Diamond 和 Card 等後端程式撰寫。

## 5 心得感想
**陳研希**：經由這次的專案，我體會到寫程式前的「規劃」是最重要的環節，尤其是與他人合作的專案更是如此，如果一開始沒有完整的溝通，便會造成誤會以至於花費不必要的時間。然後確實理解前後端是怎麼互動的也是未來要精進的部分，還沒做的時候都不知道這是不容易的問題。總結本次專案，除了又好好複習了學期後半教的觀念和方法，也在與組員的合作中增進了合作能力，是很有收穫的一次專案。

**張弘蒲**：有了這次專案，我總算是明白了小傑老師在學期間不斷強調「一個好的程式並不是能夠達成任務、解決問題就好，而是要能夠簡化與他人合作的溝通成本」，也許這次專案是有辦法一個人從頭到尾刻出來，但要是如此，我們也無法明白「溝通」、「規劃」、「易讀性」對程式設計師來說是何等重要的技能。最後，在這次專案中沒能使用到繼承、多型滿可惜的，畢竟寫作業花了好多時間搞懂他們。

**莫仲軒**：透過這次的分工以及合作，更加深刻的理解到事先溝通介面的重要性，因為這樣的專案需要進行分工，倘若沒有事先溝通好函數的輸入輸出、變數的名稱、各類別中須包含的函式，最後合併時，會出現相當大的問題。經過這次專案除了理解到遊戲前後端的連動方法，也更加深刻的體會到類別間的互動關係，將這學期的重點「Class」給完整的複習並實作了一次，相信對未來的程式之路會有很顯著的幫助。

**羅佳璿**：這次專案有別於以往個人作業，與組員一同寫出一支較複雜的程式是一個全新的體驗。雖然在過程中需要的大量溝通、確認彼此想法花了我們不少時間，但同時也能彌補對方邏輯上之闕漏、沒有注意到的細節。除此之外，透過這次嘗試也讓我發現原來不是後端寫一寫丟到前端就能輕鬆合併，反而透過前端的想法來決定後端怎麼開發會更順暢。最後，很可惜沒能好好運用繼承、多型，對 exception hadling 的運用也有所侷限，希望之後能有機會好好運用這些酷功能完成一支更完整的 OOP 專案!
